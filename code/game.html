<!DOCTYPE html>
<html>
  <head>
    <title>AR Navigation to Islington College</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      video#camera {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: 1;
      }

      #navigation-arrow {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 100px;
        height: 100px;
        transform: translate(-50%, -50%);
        z-index: 10;
        transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.3));
      }

      #status-bar {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.9) 0%,
          rgba(0, 0, 0, 0.7) 100%
        );
        color: white;
        padding: 20px;
        z-index: 15;
        backdrop-filter: blur(10px);
      }

      #checkpoint-status {
        font-size: 16px;
        font-weight: 600;
        color: #4caf50;
        margin-bottom: 8px;
      }

      #route-info {
        font-size: 14px;
        color: #e0e0e0;
      }

      #main-instruction {
        position: absolute;
        top: 45%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 20px 30px;
        border-radius: 25px;
        z-index: 12;
        text-align: center;
        backdrop-filter: blur(15px);
        border: 2px solid #4caf50;
        min-width: 280px;
      }

      #direction-text {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 10px;
        color: #4caf50;
      }

      #distance-info {
        font-size: 16px;
        color: #fff;
        opacity: 0.9;
      }

      #bottom-panel {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(
          0deg,
          rgba(0, 0, 0, 0.9) 0%,
          rgba(0, 0, 0, 0.7) 100%
        );
        color: white;
        padding: 20px;
        z-index: 15;
        backdrop-filter: blur(10px);
      }

      #checkpoints-progress {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        flex-wrap: wrap;
        gap: 10px;
      }

      .checkpoint {
        flex: 1;
        text-align: center;
        padding: 8px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        min-width: 80px;
        transition: all 0.3s ease;
      }

      .checkpoint.pending {
        background: rgba(158, 158, 158, 0.3);
        color: #9e9e9e;
        border: 1px solid #616161;
      }

      .checkpoint.reached {
        background: rgba(76, 175, 80, 0.3);
        color: #4caf50;
        border: 1px solid #4caf50;
        animation: pulse 2s infinite;
      }

      .checkpoint.current {
        background: rgba(255, 193, 7, 0.3);
        color: #ffc107;
        border: 1px solid #ffc107;
        animation: glow 2s ease-in-out infinite alternate;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      @keyframes glow {
        from {
          box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
        }
        to {
          box-shadow: 0 0 20px rgba(255, 193, 7, 0.8),
            0 0 30px rgba(255, 193, 7, 0.6);
        }
      }

      #accuracy-indicator {
        display: flex;
        justify-content: space-between;
        font-size: 11px;
        color: #bdbdbd;
      }

      .accuracy-good {
        color: #4caf50;
      }
      .accuracy-fair {
        color: #ffc107;
      }
      .accuracy-poor {
        color: #f44336;
      }

      #controls {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 16;
      }

      .control-btn {
        display: block;
        padding: 12px 20px;
        margin-bottom: 10px;
        border: none;
        border-radius: 25px;
        background: rgba(244, 67, 54, 0.9);
        color: white;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        backdrop-filter: blur(10px);
        transition: all 0.3s ease;
      }

      .control-btn:hover {
        background: rgba(244, 67, 54, 1);
        transform: translateY(-2px);
      }

      .control-btn.recalibrate {
        background: rgba(33, 150, 243, 0.9);
      }

      .control-btn.recalibrate:hover {
        background: rgba(33, 150, 243, 1);
      }

      .error-message {
        background: rgba(244, 67, 54, 0.95) !important;
        border-color: #f44336 !important;
        animation: shake 0.5s ease-in-out;
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-10px);
        }
        75% {
          transform: translateX(10px);
        }
      }

      .arrival-celebration {
        background: linear-gradient(45deg, #4caf50, #8bc34a) !important;
        border-color: #4caf50 !important;
        animation: celebrate 1s ease-in-out infinite alternate;
      }

      @keyframes celebrate {
        from {
          transform: translateX(-50%) scale(1);
        }
        to {
          transform: translateX(-50%) scale(1.05);
        }
      }
    </style>
  </head>
  <body>
    <video id="camera" autoplay playsinline></video>

    <!-- Custom Arrow SVG -->
    <svg id="navigation-arrow" viewBox="0 0 100 100">
      <defs>
        <linearGradient id="arrowGradient" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" style="stop-color: #4caf50; stop-opacity: 1" />
          <stop offset="100%" style="stop-color: #2e7d32; stop-opacity: 1" />
        </linearGradient>
        <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
          <feDropShadow
            dx="0"
            dy="4"
            stdDeviation="6"
            flood-color="rgba(0,0,0,0.4)"
          />
        </filter>
      </defs>
      <path
        d="M50 5 L20 35 L35 35 L35 70 L65 70 L65 35 L80 35 Z"
        fill="url(#arrowGradient)"
        stroke="#1B5E20"
        stroke-width="2"
        filter="url(#shadow)"
      />
    </svg>

    <div id="status-bar">
      <div id="checkpoint-status">Initializing GPS...</div>
      <div id="route-info">Calculating route to Islington College</div>
    </div>

    <div id="main-instruction">
      <div id="direction-text">Starting Navigation</div>
      <div id="distance-info">Please wait...</div>
    </div>

    <div id="bottom-panel">
      <div id="checkpoints-progress">
        <div class="checkpoint pending" data-checkpoint="start">Start</div>
        <div class="checkpoint pending" data-checkpoint="putalisadak">
          Putalisadak
        </div>
        <div class="checkpoint pending" data-checkpoint="maitighar">
          Maitighar
        </div>
        <div class="checkpoint pending" data-checkpoint="naxal">Naxal</div>
        <div class="checkpoint pending" data-checkpoint="destination">
          Islington
        </div>
      </div>
      <div id="accuracy-indicator">
        <span>GPS: <span id="gps-accuracy">--</span></span>
        <span>Compass: <span id="compass-accuracy">--</span></span>
        <span>Bearing: <span id="bearing-info">--Â°</span></span>
      </div>
    </div>

    <div id="controls">
      <button class="control-btn recalibrate" id="recalibrateBtn">
        Recalibrate
      </button>
      <button class="control-btn" id="stopBtn">Stop</button>
    </div>

    <script>
      // Configuration
      const CONFIG = {
        destination: { lat: 27.709238899431625, lng: 85.32558477122376 }, // Islington College
        checkpoints: [
          {
            id: "putalisadak",
            name: "Putalisadak",
            lat: 27.7056,
            lng: 85.3139,
            radius: 200,
          },
          {
            id: "maitighar",
            name: "Maitighar",
            lat: 27.6939,
            lng: 85.315,
            radius: 250,
          },
          {
            id: "naxal",
            name: "Naxal",
            lat: 27.7085,
            lng: 85.3263,
            radius: 300,
          },
        ],
        accuracyThreshold: 20, // meters
        compassCalibrationSamples: 10,
        minMovementDistance: 5, // meters
      };

      // State management
      let state = {
        userLocation: null,
        deviceHeading: 0,
        routeSteps: [],
        currentStepIndex: 0,
        isNavigating: false,
        watchId: null,
        compassSamples: [],
        lastKnownLocation: null,
        checkpointsReached: [],
        totalDistance: 0,
        gpsAccuracy: 0,
        compassAccuracy: "unknown",
      };

      // DOM elements
      const elements = {
        video: document.getElementById("camera"),
        arrow: document.getElementById("navigation-arrow"),
        statusBar: document.getElementById("status-bar"),
        checkpointStatus: document.getElementById("checkpoint-status"),
        routeInfo: document.getElementById("route-info"),
        mainInstruction: document.getElementById("main-instruction"),
        directionText: document.getElementById("direction-text"),
        distanceInfo: document.getElementById("distance-info"),
        checkpointsProgress: document.getElementById("checkpoints-progress"),
        gpsAccuracy: document.getElementById("gps-accuracy"),
        compassAccuracy: document.getElementById("compass-accuracy"),
        bearingInfo: document.getElementById("bearing-info"),
        recalibrateBtn: document.getElementById("recalibrateBtn"),
        stopBtn: document.getElementById("stopBtn"),
      };

      // Utility functions
      function calculateDistance(lat1, lng1, lat2, lng2) {
        const R = 6371000; // Earth's radius in meters
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLng = ((lng2 - lng1) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLng / 2) *
            Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      function calculateBearing(lat1, lng1, lat2, lng2) {
        const dLng = ((lng2 - lng1) * Math.PI) / 180;
        const lat1Rad = (lat1 * Math.PI) / 180;
        const lat2Rad = (lat2 * Math.PI) / 180;

        const y = Math.sin(dLng) * Math.cos(lat2Rad);
        const x =
          Math.cos(lat1Rad) * Math.sin(lat2Rad) -
          Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);

        let bearing = (Math.atan2(y, x) * 180) / Math.PI;
        return (bearing + 360) % 360;
      }

      function normalizeAngle(angle) {
        return ((angle % 360) + 360) % 360;
      }

      function getDirectionInstruction(relativeAngle) {
        const angle = normalizeAngle(relativeAngle);

        if (angle >= 350 || angle <= 10)
          return { text: "Continue straight", color: "#4CAF50" };
        if (angle > 10 && angle <= 30)
          return { text: "Slight right ahead", color: "#2196F3" };
        if (angle > 30 && angle <= 60)
          return { text: "Turn right", color: "#2196F3" };
        if (angle > 60 && angle <= 120)
          return { text: "Sharp right turn", color: "#2196F3" };
        if (angle > 120 && angle <= 180)
          return { text: "U-turn right", color: "#FF5722" };
        if (angle > 180 && angle <= 240)
          return { text: "U-turn left", color: "#FF5722" };
        if (angle > 240 && angle <= 300)
          return { text: "Sharp left turn", color: "#FF9800" };
        if (angle > 300 && angle <= 330)
          return { text: "Turn left", color: "#FF9800" };
        if (angle > 330 && angle < 350)
          return { text: "Slight left ahead", color: "#FF9800" };

        return { text: "Continue", color: "#4CAF50" };
      }

      function formatDistance(meters) {
        if (meters < 1000) {
          return `${Math.round(meters)}m`;
        } else {
          return `${(meters / 1000).toFixed(1)}km`;
        }
      }

      // Camera initialization
      async function initializeCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: "environment",
              width: { ideal: 1280 },
              height: { ideal: 720 },
            },
          });
          elements.video.srcObject = stream;
          return true;
        } catch (error) {
          console.error("Camera initialization failed:", error);
          showError("Camera access denied. Please enable camera permissions.");
          return false;
        }
      }

      // Location services
      function getCurrentLocation() {
        return new Promise((resolve, reject) => {
          if (!navigator.geolocation) {
            reject(new Error("Geolocation not supported"));
            return;
          }

          navigator.geolocation.getCurrentPosition(
            (position) => {
              const location = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy,
                timestamp: position.timestamp,
              };

              state.userLocation = location;
              state.gpsAccuracy = position.coords.accuracy;
              resolve(location);
            },
            (error) => {
              let message = "Location access denied";
              if (error.code === error.TIMEOUT) message = "Location timeout";
              else if (error.code === error.POSITION_UNAVAILABLE)
                message = "Location unavailable";
              reject(new Error(message));
            },
            {
              enableHighAccuracy: true,
              timeout: 15000,
              maximumAge: 5000,
            }
          );
        });
      }

      // Route calculation with proper OSRM integration
      async function calculateRoute(startLat, startLng, endLat, endLng) {
        try {
          const url = `https://router.project-osrm.org/route/v1/driving/${startLng},${startLat};${endLng},${endLat}?steps=true&geometries=geojson&overview=full`;

          const response = await fetch(url);
          const data = await response.json();

          if (!data.routes || data.routes.length === 0) {
            throw new Error("No route found");
          }

          const route = data.routes[0];
          const steps = route.legs[0].steps;

          state.totalDistance = route.distance;

          return steps.map((step) => ({
            instruction:
              step.maneuver.instruction ||
              getInstructionFromManeuver(step.maneuver),
            distance: step.distance,
            duration: step.duration,
            location: step.maneuver.location,
            bearing_after: step.maneuver.bearing_after || 0,
            maneuver_type: step.maneuver.type,
          }));
        } catch (error) {
          console.error("Route calculation failed:", error);
          throw new Error(
            "Failed to calculate route. Check your internet connection."
          );
        }
      }

      function getInstructionFromManeuver(maneuver) {
        const typeMap = {
          depart: "Head out",
          "turn-right": "Turn right",
          "turn-left": "Turn left",
          "turn-sharp-right": "Sharp right",
          "turn-sharp-left": "Sharp left",
          "turn-slight-right": "Slight right",
          "turn-slight-left": "Slight left",
          continue: "Continue straight",
          arrive: "Arrive at destination",
        };
        return typeMap[maneuver.type] || "Continue";
      }

      // Enhanced compass handling
      function handleOrientation(event) {
        let heading = null;

        if (event.webkitCompassHeading) {
          heading = event.webkitCompassHeading;
          state.compassAccuracy = "iOS Compass";
        } else if (event.alpha !== null) {
          heading = 360 - event.alpha; // Convert to compass heading
          state.compassAccuracy = "Android Magnetometer";
        }

        if (heading !== null) {
          // Smooth compass readings
          state.compassSamples.push(heading);
          if (state.compassSamples.length > CONFIG.compassCalibrationSamples) {
            state.compassSamples.shift();
          }

          // Calculate average for smooth movement
          const avgHeading =
            state.compassSamples.reduce((a, b) => a + b, 0) /
            state.compassSamples.length;
          state.deviceHeading = avgHeading;

          updateNavigation();
        }
      }

      // Checkpoint management
      function checkCheckpoints() {
        if (!state.userLocation) return;

        CONFIG.checkpoints.forEach((checkpoint) => {
          if (state.checkpointsReached.includes(checkpoint.id)) return;

          const distance = calculateDistance(
            state.userLocation.lat,
            state.userLocation.lng,
            checkpoint.lat,
            checkpoint.lng
          );

          if (distance <= checkpoint.radius) {
            state.checkpointsReached.push(checkpoint.id);
            updateCheckpointUI(checkpoint.id, "reached");

            elements.checkpointStatus.textContent = `âœ“ Reached ${checkpoint.name}`;
            elements.checkpointStatus.style.animation =
              "pulse 1s ease-in-out 3";

            // Haptic feedback if available
            if (navigator.vibrate) {
              navigator.vibrate([100, 50, 100]);
            }
          }
        });

        // Update current target checkpoint
        const nextCheckpoint = CONFIG.checkpoints.find(
          (cp) => !state.checkpointsReached.includes(cp.id)
        );

        if (nextCheckpoint) {
          updateCheckpointUI(nextCheckpoint.id, "current");
        }
      }

      function updateCheckpointUI(checkpointId, status) {
        const element = document.querySelector(
          `[data-checkpoint="${checkpointId}"]`
        );
        if (element) {
          element.className = `checkpoint ${status}`;
        }
      }

      // Enhanced navigation logic
      function getCurrentNavigationStep() {
        if (!state.routeSteps.length || !state.userLocation) return null;

        // Find closest step that's ahead of us
        let minDistance = Infinity;
        let bestStepIndex = state.currentStepIndex;

        for (let i = state.currentStepIndex; i < state.routeSteps.length; i++) {
          const step = state.routeSteps[i];
          const stepLat = step.location[1];
          const stepLng = step.location[0];

          const distance = calculateDistance(
            state.userLocation.lat,
            state.userLocation.lng,
            stepLat,
            stepLng
          );

          if (distance < minDistance) {
            minDistance = distance;
            bestStepIndex = i;
          }
        }

        // Auto-advance if we're very close to current step
        if (
          minDistance < CONFIG.accuracyThreshold &&
          bestStepIndex === state.currentStepIndex &&
          state.currentStepIndex < state.routeSteps.length - 1
        ) {
          state.currentStepIndex++;
          return state.routeSteps[state.currentStepIndex];
        }

        state.currentStepIndex = bestStepIndex;
        return state.routeSteps[state.currentStepIndex];
      }

      function updateNavigation() {
        if (
          !state.isNavigating ||
          !state.userLocation ||
          !state.routeSteps.length
        )
          return;

        const currentStep = getCurrentNavigationStep();
        if (!currentStep) return;

        // Calculate navigation metrics
        const stepLat = currentStep.location[1];
        const stepLng = currentStep.location[0];

        const distanceToStep = calculateDistance(
          state.userLocation.lat,
          state.userLocation.lng,
          stepLat,
          stepLng
        );

        const bearingToStep = calculateBearing(
          state.userLocation.lat,
          state.userLocation.lng,
          stepLat,
          stepLng
        );

        const relativeAngle = normalizeAngle(
          bearingToStep - state.deviceHeading
        );
        const direction = getDirectionInstruction(relativeAngle);

        // Update UI
        updateArrow(relativeAngle);
        updateInstructionPanel(currentStep, direction, distanceToStep);
        updateStatusBar(currentStep, distanceToStep);
        updateAccuracyIndicators(bearingToStep);

        // Check checkpoints
        checkCheckpoints();

        // Check arrival
        const distanceToDestination = calculateDistance(
          state.userLocation.lat,
          state.userLocation.lng,
          CONFIG.destination.lat,
          CONFIG.destination.lng
        );

        if (distanceToDestination < 50) {
          handleArrival();
        }
      }

      function updateArrow(relativeAngle) {
        elements.arrow.style.transform = `translate(-50%, -50%) rotate(${relativeAngle}deg)`;
      }

      function updateInstructionPanel(step, direction, distance) {
        elements.directionText.textContent = direction.text;
        elements.directionText.style.color = direction.color;
        elements.distanceInfo.textContent = `${formatDistance(distance)} â€¢ ${
          step.instruction
        }`;
      }

      function updateStatusBar(step, distance) {
        const progress = `${state.currentStepIndex + 1}/${
          state.routeSteps.length
        }`;
        elements.routeInfo.textContent = `Step ${progress} â€¢ ${formatDistance(
          state.totalDistance
        )} total`;
      }

      function updateAccuracyIndicators(bearing) {
        // GPS accuracy indicator
        let gpsStatus = "poor";
        if (state.gpsAccuracy < 10) gpsStatus = "good";
        else if (state.gpsAccuracy < 20) gpsStatus = "fair";

        elements.gpsAccuracy.textContent = `${Math.round(state.gpsAccuracy)}m`;
        elements.gpsAccuracy.className = `accuracy-${gpsStatus}`;

        // Compass accuracy
        elements.compassAccuracy.textContent = state.compassAccuracy;
        elements.bearingInfo.textContent = `${Math.round(bearing)}Â°`;
      }

      function handleArrival() {
        elements.directionText.textContent = "ðŸŽ‰ Arrived at Islington College!";
        elements.distanceInfo.textContent = "You have reached your destination";
        elements.mainInstruction.classList.add("arrival-celebration");

        updateCheckpointUI("destination", "reached");

        if (navigator.vibrate) {
          navigator.vibrate([200, 100, 200, 100, 200]);
        }
      }

      // Location tracking
      function startLocationTracking() {
        if (!navigator.geolocation) return;

        state.watchId = navigator.geolocation.watchPosition(
          (position) => {
            const newLocation = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              accuracy: position.coords.accuracy,
              timestamp: position.timestamp,
            };

            // Only update if we've moved significantly or accuracy improved
            if (
              !state.lastKnownLocation ||
              calculateDistance(
                state.lastKnownLocation.lat,
                state.lastKnownLocation.lng,
                newLocation.lat,
                newLocation.lng
              ) > CONFIG.minMovementDistance ||
              newLocation.accuracy < state.gpsAccuracy
            ) {
              state.userLocation = newLocation;
              state.gpsAccuracy = position.coords.accuracy;
              state.lastKnownLocation = newLocation;
              updateNavigation();
            }
          },
          (error) => console.error("Location tracking error:", error),
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 2000,
          }
        );
      }

      function stopLocationTracking() {
        if (state.watchId) {
          navigator.geolocation.clearWatch(state.watchId);
          state.watchId = null;
        }
      }

      // Device orientation setup
      function setupOrientation() {
        if (!window.DeviceOrientationEvent) {
          showError("Device orientation not supported");
          return;
        }

        // Request permission on iOS
        if (typeof DeviceOrientationEvent.requestPermission === "function") {
          DeviceOrientationEvent.requestPermission()
            .then((response) => {
              if (response === "granted") {
                window.addEventListener(
                  "deviceorientationabsolute",
                  handleOrientation
                );
              } else {
                showError("Compass permission denied");
              }
            })
            .catch(console.error);
        } else {
          // Android or older iOS
          if ("ondeviceorientationabsolute" in window) {
            window.addEventListener(
              "deviceorientationabsolute",
              handleOrientation
            );
          } else {
            window.addEventListener("deviceorientation", handleOrientation);
          }
        }
      }

      // Error handling
      function showError(message) {
        elements.mainInstruction.classList.add("error-message");
        elements.directionText.textContent = "Error";
        elements.distanceInfo.textContent = message;

        setTimeout(() => {
          elements.mainInstruction.classList.remove("error-message");
        }, 5000);
      }

      // Main initialization
      async function startNavigation() {
        try {
          elements.checkpointStatus.textContent = "Initializing camera...";
          await initializeCamera();

          elements.checkpointStatus.textContent = "Getting your location...";
          await getCurrentLocation();

          updateCheckpointUI("start", "reached");
          state.checkpointsReached.push("start");

          elements.checkpointStatus.textContent =
            "Calculating optimal route...";
          state.routeSteps = await calculateRoute(
            state.userLocation.lat,
            state.userLocation.lng,
            CONFIG.destination.lat,
            CONFIG.destination.lng
          );

          elements.checkpointStatus.textContent =
            "Starting navigation to Islington College";

          state.isNavigating = true;
          setupOrientation();
          startLocationTracking();

          updateNavigation();
        } catch (error) {
          showError(error.message);
        }
      }

      // Event listeners
      elements.recalibrateBtn.addEventListener("click", () => {
        state.compassSamples = [];
        elements.checkpointStatus.textContent = "Recalibrating compass...";
        setTimeout(() => {
          elements.checkpointStatus.textContent = "Navigation active";
        }, 2000);
      });

      elements.stopBtn.addEventListener("click", () => {
        state.isNavigating = false;
        stopLocationTracking();
        elements.checkpointStatus.textContent = "Navigation stopped";
        elements.directionText.textContent = "Navigation stopped";
        elements.distanceInfo.textContent = "Tap start to begin navigation";
      });

      // Initialize app
      startNavigation();
    </script>
  </body>
</html>
